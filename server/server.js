const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const Stripe = require('stripe');
const fetch = require('node-fetch');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3002;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Stripe
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// Telegram Bot Configuration
const TELEGRAM_BOT_TOKEN = '7788182965:AAEiUmRg4l_HvaV3honhiVZluu_gFadOcrA';
const TELEGRAM_CHAT_ID = '-1002604809855';

// Telegram helper function
async function sendTelegramMessage(text) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chat_id: TELEGRAM_CHAT_ID,
        text: text,
        parse_mode: 'HTML',
        disable_web_page_preview: true,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('‚ùå Telegram API error:', errorData);
      return false;
    }

    const result = await response.json();
    console.log('‚úÖ Telegram message sent:', result.result.message_id);
    return true;
  } catch (error) {
    console.error('‚ùå Failed to send Telegram message:', error);
    return false;
  }
}

// Middleware
app.use(cors({
  origin: ['http://localhost:5173', 'http://localhost:5174', 'http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// –û—Ç–¥–µ–ª—å–Ω—ã–π middleware –¥–ª—è webhook (—Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ)
app.use('/api/stripe/webhook', bodyParser.raw({ type: 'application/json' }));

// JSON parser –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö endpoints
app.use(express.json());

// –ü—Ä–æ–¥—É–∫—Ç—ã Stripe
const STRIPE_PRODUCTS = [
  {
    id: 'monthly-subscription',
    name: 'Monthly Subscription',
    priceId: 'price_1RiUt0AK7V4m73aluYckgD6P',
    productId: 'prod_SdmRKnaMEM7FE7',
    credits: 250,
    mode: 'subscription'
  },
  {
    id: 'small-topup',
    name: 'Small Credits',
    priceId: 'price_1RiUvhAK7V4m73alSPDpllg2',
    productId: 'prod_SdmU9mybV0ZUhw',
    credits: 100,
    mode: 'payment'
  },
  {
    id: 'medium-topup',
    name: 'Medium Credits',
    priceId: 'price_1RiUxdAK7V4m73alz8Oad0YH',
    productId: 'prod_SdmWCbIxv9eioK',
    credits: 500,
    mode: 'payment'
  },
  {
    id: 'xxl-topup',
    name: 'XXL Credits',
    priceId: 'price_1RiUyPAK7V4m73alBCuO8sYC',
    productId: 'prod_SdmXQUfirQZKGf',
    credits: 1500,
    mode: 'payment'
  }
];

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–∞ –ø–æ price ID
function getProductByPriceId(priceId) {
  return STRIPE_PRODUCTS.find(product => product.priceId === priceId);
}

// API endpoint –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è checkout session
app.post('/api/stripe/create-checkout-session', async (req, res) => {
  try {
    console.log('üìù Received checkout session request:', req.body);
    
    const { priceId, mode, successUrl, cancelUrl, customerEmail, userId, credits } = req.body;
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (!priceId || !mode || !successUrl || !cancelUrl || !customerEmail || !userId) {
      return res.status(400).json({ 
        error: 'Missing required fields', 
        required: ['priceId', 'mode', 'successUrl', 'cancelUrl', 'customerEmail', 'userId'] 
      });
    }
    
    const product = getProductByPriceId(priceId);
    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }

    console.log('üîç Found product:', product);

    // –ù–∞—Ö–æ–¥–∏–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º customer
    let customer;
    const existingCustomers = await stripe.customers.list({
      email: customerEmail,
      limit: 1
    });

    if (existingCustomers.data.length > 0) {
      customer = existingCustomers.data[0];
      console.log('üë§ Found existing customer:', customer.id);
    } else {
      customer = await stripe.customers.create({
        email: customerEmail,
        metadata: {
          userId: userId
        }
      });
      console.log('üÜï Created new customer:', customer.id);
    }

    // –°–æ–∑–¥–∞–µ–º checkout session
    const session = await stripe.checkout.sessions.create({
      customer: customer.id,
      payment_method_types: ['card'],
      line_items: [{
        price: priceId,
        quantity: 1,
      }],
      mode: mode,
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: {
        userId: userId,
        credits: credits ? credits.toString() : product.credits.toString(),
        priceId: priceId
      }
    });

    console.log('‚úÖ Created checkout session:', session.id);

    res.json({
      id: session.id,
      url: session.url
    });
  } catch (error) {
    console.error('‚ùå Error creating checkout session:', error);
    res.status(500).json({ error: error.message });
  }
});

// API endpoint –¥–ª—è –æ—Ç–º–µ–Ω—ã –ø–æ–¥–ø–∏—Å–∫–∏
app.post('/api/stripe/cancel-subscription', async (req, res) => {
  try {
    const { subscriptionId } = req.body;
    
    if (!subscriptionId) {
      return res.status(400).json({ error: 'Missing subscriptionId' });
    }
    
    const subscription = await stripe.subscriptions.update(subscriptionId, {
      cancel_at_period_end: true
    });

    console.log('üö´ Subscription cancelled:', subscriptionId);
    
    res.json({ success: true, subscription });
  } catch (error) {
    console.error('‚ùå Error canceling subscription:', error);
    res.status(500).json({ error: error.message });
  }
});

// Webhook endpoint –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π Stripe
app.post('/api/stripe/webhook', (req, res) => {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
    console.log('üîî Received webhook:', event.type);
  } catch (err) {
    console.error('‚ùå Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ
  handleStripeEvent(event);

  res.json({ received: true });
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π Stripe
async function handleStripeEvent(event) {
  try {
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutSessionCompleted(event.data.object);
        break;
      
      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object);
        break;
      
      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object);
        break;
      
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object);
        break;
      
      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object);
        break;
      
      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object);
        break;
      
      default:
        console.log(`‚ö†Ô∏è  Unhandled event type: ${event.type}`);
    }
  } catch (error) {
    console.error('‚ùå Error handling stripe event:', error);
  }
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
async function handleCheckoutSessionCompleted(session) {
  console.log('‚úÖ Checkout session completed:', session.id);
  
  try {
    // Get session details
    const userId = session.metadata?.userId || 'Unknown';
    const credits = session.metadata?.credits || 'N/A';
    const priceId = session.metadata?.priceId;
    
    // Find product info
    const product = getProductByPriceId(priceId);
    const productName = product ? product.name : 'Unknown Product';
    
    // Get customer info
    const customer = await stripe.customers.retrieve(session.customer);
    const customerEmail = customer.email || 'Unknown';
    
    const isSubscription = session.mode === 'subscription';
    const amountFormatted = (session.amount_total / 100).toFixed(2);
    
    // Format Telegram message
    let message = `üí∞ <b>–ù–æ–≤–∞—è –æ–ø–ª–∞—Ç–∞ –≤ Donein5!</b>\n\n`;
    
    if (isSubscription) {
      message += `üîÑ <b>–¢–∏–ø:</b> –ü–æ–¥–ø–∏—Å–∫–∞\n`;
      message += `üì¶ <b>–ü—Ä–æ–¥—É–∫—Ç:</b> ${productName}\n`;
      message += `üíµ <b>–°—É–º–º–∞:</b> $${amountFormatted}/–º–µ—Å—è—Ü\n`;
      if (credits && credits !== 'N/A') {
        message += `‚ö° <b>–ö—Ä–µ–¥–∏—Ç—ã:</b> ${credits} –≤ –º–µ—Å—è—Ü\n`;
      }
    } else {
      message += `üõí <b>–¢–∏–ø:</b> –†–∞–∑–æ–≤–∞—è –ø–æ–∫—É–ø–∫–∞\n`;
      message += `üì¶ <b>–ü—Ä–æ–¥—É–∫—Ç:</b> ${productName}\n`;
      message += `üíµ <b>–°—É–º–º–∞:</b> $${amountFormatted}\n`;
      if (credits && credits !== 'N/A') {
        message += `‚ö° <b>–ö—Ä–µ–¥–∏—Ç—ã:</b> ${credits}\n`;
        const creditPrice = (session.amount_total / 100 / parseInt(credits)).toFixed(3);
        message += `üíé <b>–¶–µ–Ω–∞ –∑–∞ –∫—Ä–µ–¥–∏—Ç:</b> $${creditPrice}\n`;
      }
    }
    
    message += `\nüë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b>\n`;
    message += `   üìß ${customerEmail}\n`;
    message += `   üÜî ${userId}\n`;
    
    message += `\nüßæ <b>Stripe Session:</b> <code>${session.id}</code>\n`;
    message += `üïê <b>–í—Ä–µ–º—è:</b> ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}\n`;
    
    message += `\n---\n`;
    message += `<i>üí´ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ Donein5 Payment System</i>`;
    
    // Send Telegram notification
    await sendTelegramMessage(message);
    
  } catch (error) {
    console.error('‚ùå Error processing checkout session completion:', error);
  }
}

async function handleSubscriptionCreated(subscription) {
  console.log('üîÑ Subscription created:', subscription.id);
  // –õ–æ–≥–∏–∫–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø–∏—Å–∏ –æ –ø–æ–¥–ø–∏—Å–∫–µ
}

async function handleSubscriptionUpdated(subscription) {
  console.log('üîÑ Subscription updated:', subscription.id);
  // –õ–æ–≥–∏–∫–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏
}

async function handleSubscriptionDeleted(subscription) {
  console.log('üóëÔ∏è  Subscription deleted:', subscription.id);
  
  try {
    // Get customer info
    const customer = await stripe.customers.retrieve(subscription.customer);
    const customerEmail = customer.email || 'Unknown';
    const userId = customer.metadata?.userId || 'Unknown';
    
    const message = `üö´ <b>–ü–æ–¥–ø–∏—Å–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞</b>\n\n` +
      `üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b>\n` +
      `   üìß ${customerEmail}\n` +
      `   üÜî ${userId}\n\n` +
      `üîÑ <b>Subscription ID:</b> <code>${subscription.id}</code>\n` +
      `üïê <b>–í—Ä–µ–º—è:</b> ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}\n\n` +
      `---\n` +
      `<i>üí´ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ Donein5 Payment System</i>`;

    await sendTelegramMessage(message);
  } catch (error) {
    console.error('‚ùå Error processing subscription deletion:', error);
  }
}

async function handleInvoicePaymentSucceeded(invoice) {
  console.log('üí∞ Invoice payment succeeded:', invoice.id);
  // –õ–æ–≥–∏–∫–∞ –¥–ª—è —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞
}

async function handleInvoicePaymentFailed(invoice) {
  console.log('‚ùå Invoice payment failed:', invoice.id);
  
  try {
    // Get customer info
    const customer = await stripe.customers.retrieve(invoice.customer);
    const customerEmail = customer.email || 'Unknown';
    const userId = customer.metadata?.userId || 'Unknown';
    
    const message = `‚ùå <b>–û—à–∏–±–∫–∞ –æ–ø–ª–∞—Ç—ã —Å—á–µ—Ç–∞</b>\n\n` +
      `üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b>\n` +
      `   üìß ${customerEmail}\n` +
      `   üÜî ${userId}\n\n` +
      `üßæ <b>Invoice ID:</b> <code>${invoice.id}</code>\n` +
      `üíµ <b>–°—É–º–º–∞:</b> $${(invoice.amount_due / 100).toFixed(2)}\n` +
      `üïê <b>–í—Ä–µ–º—è:</b> ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}\n\n` +
      `---\n` +
      `<i>üí´ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ Donein5 Payment System</i>`;

    await sendTelegramMessage(message);
  } catch (error) {
    console.error('‚ùå Error processing invoice payment failure:', error);
  }
}

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    stripe_configured: !!process.env.STRIPE_SECRET_KEY,
    telegram_configured: !!(TELEGRAM_BOT_TOKEN && TELEGRAM_CHAT_ID)
  });
});

// Test Telegram notification endpoint
app.post('/api/telegram/test', async (req, res) => {
  try {
    const message = `üß™ <b>Test –æ—Ç Donein5</b>\n\n` +
      `‚úÖ Telegram –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç!\n` +
      `üïê ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}`;

    const success = await sendTelegramMessage(message);
    
    if (success) {
      res.json({ success: true, message: 'Test message sent successfully' });
    } else {
      res.status(500).json({ success: false, error: 'Failed to send test message' });
    }
  } catch (error) {
    console.error('‚ùå Telegram test failed:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});


// Handle preflight requests for Telegram endpoint
app.options('/api/telegram/notify-idea', (req, res) => {
  const origin = req.headers.origin;
  const allowedOrigins = ['http://localhost:5173', 'http://localhost:5174', 'http://localhost:3000'];
  
  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  }
  res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.status(200).end();
});

// Notify about new idea suggestion
app.post('/api/telegram/notify-idea', async (req, res) => {
  // –î–æ–±–∞–≤–ª—è–µ–º CORS –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è POST –∑–∞–ø—Ä–æ—Å–∞
  const origin = req.headers.origin;
  const allowedOrigins = ['http://localhost:5173', 'http://localhost:5174', 'http://localhost:3000'];
  
  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  }
  res.header('Access-Control-Allow-Credentials', 'true');
  
  try {
    console.log('üìù –ü–æ–ª—É—á–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–π –∏–¥–µ–µ:', req.body);
    
    const { idea } = req.body;
    
    if (!idea) {
      return res.status(400).json({ error: 'Missing idea data' });
    }

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∏–¥–µ–∏
    const categoryEmojis = {
      'new_agent': 'ü§ñ',
      'feature_improvement': '‚ö°',
      'ui_enhancement': 'üé®',
      'integration': 'üîó',
      'other': 'üí°'
    };

    const priorityEmojis = {
      'low': 'üü¢',
      'medium': 'üü°',
      'high': 'üü†',
      'urgent': 'üî¥'
    };

    const categoryNames = {
      'new_agent': '–ù–æ–≤—ã–π –∞–≥–µ–Ω—Ç',
      'feature_improvement': '–£–ª—É—á—à–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π',
      'ui_enhancement': '–£–ª—É—á—à–µ–Ω–∏–µ UI',
      'integration': '–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è',
      'other': '–î—Ä—É–≥–æ–µ'
    };

    const priorityNames = {
      'low': '–ù–∏–∑–∫–∏–π',
      'medium': '–°—Ä–µ–¥–Ω–∏–π', 
      'high': '–í—ã—Å–æ–∫–∏–π',
      'urgent': '–°—Ä–æ—á–Ω—ã–π'
    };

    const categoryEmoji = categoryEmojis[idea.category] || 'üí°';
    const priorityEmoji = priorityEmojis[idea.priority] || 'üü°';
    const categoryName = categoryNames[idea.category] || idea.category;
    const priorityName = priorityNames[idea.priority] || idea.priority;

    const formattedDate = new Date(idea.created_at).toLocaleString('ru-RU', {
      timeZone: 'Europe/Moscow',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });

    const message = `üöÄ <b>–ù–æ–≤–∞—è –∏–¥–µ—è –¥–ª—è Donein5!</b>\n\n` +
      `${categoryEmoji} <b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> ${categoryName}\n` +
      `${priorityEmoji} <b>–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:</b> ${priorityName}\n\n` +
      `üìù <b>–ó–∞–≥–æ–ª–æ–≤–æ–∫:</b>\n${idea.title}\n\n` +
      `üìã <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n${idea.description}\n\n` +
      `üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> ${idea.user_id ? `ID: ${idea.user_id}` : '–ê–Ω–æ–Ω–∏–º–Ω—ã–π'}\n` +
      `üïê <b>–í—Ä–µ–º—è:</b> ${formattedDate}\n` +
      `üÜî <b>ID –∏–¥–µ–∏:</b> <code>${idea.id}</code>\n\n` +
      `---\n` +
      `<i>–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑ Donein5</i>`;

    const success = await sendTelegramMessage(message);
    
    if (success) {
      console.log('‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –∏–¥–µ–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram');
      res.json({ success: true, message: 'Idea notification sent to Telegram' });
    } else {
      console.log('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –∏–¥–µ–µ');
      res.status(500).json({ success: false, error: 'Failed to send idea notification' });
    }
  } catch (error) {
    console.error('‚ùå Error sending idea notification:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(port, () => {
  console.log(`üöÄ Stripe server running on port ${port}`);
  console.log(`üìä Health check: http://localhost:${port}/health`);
  console.log(`üîë Stripe configured: ${!!process.env.STRIPE_SECRET_KEY}`);
}); 